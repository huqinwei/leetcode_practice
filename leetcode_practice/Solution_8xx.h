#pragma once
#pragma once
#include <vector>
#include <algorithm>
#include "math.h"
#include <iostream>
#include <map>
#include "base.h"
#include <unordered_map>

class Solution_8xx {
public:

    //876 链表的中间节点：我想了一下，强行造环，快慢指针相遇也不行，也是至少遍历一圈再追半圈
    ListNode* middleNode(ListNode* head);




    //887扔鸡蛋，问找到f的最小次数！


    //思路：如果k大于1，可以用二分查找，如果k不大于1，必须从头迭代
    //例题1：只有一个蛋，遍历两层楼，尝试1楼和2楼
    //例题2：有两个蛋，先二分，n=6，最坏情况下，3楼碎了，左侧是1楼和2楼，右侧是4楼5楼6楼，右侧好像是1+3？可能最后一楼不用遍历？看例题1，是应该要遍历的，不然没法得出f=n的情况。
    //这里的技巧是，二分，也不完全是二分，如果得出右侧，那么第一个蛋没碎，如果得出左侧，那么才是剩下的遍历
    //左侧是1+2，右侧的左侧是，右侧的右侧是
    //最好写递归，其实就是求二叉树的深度

    //中间问题：mid在哪的问题，因为不是下标传递，所以可能会绕一点，但是解决了这种边界问题也没有能正确解题，重点在这个“最小”


    //动态规划：
    //乍一看是二叉树题，其实也不完全是，二分的思维能大概解决问题，但是达不到题目要求的精确数值，这里拿到最优数值是个动态平衡的过程
    //“最小”是一个动态的过程，不是一个恒定的方法能算出来，如果你只有一个蛋，你就不能二分了，所以是左遍历右二叉树两种形态的并存
    //如果右侧二叉树分担一半数值，n/2，做成二叉树大概是O(log(n/2))，但是左侧如果鸡蛋不够，复杂度会是O(n/2)
    //但是这个右侧也不是标准的二叉树，它的左左左左半（不一定是第一层，但肯定是最底层）仍然是遍历
    //平衡左侧
    int superEggDrop(int k, int n);

};
